#include <iostream>
#include "commandQ.h"

#include <string>
#include <sstream>

#define SIZE 2000
void parse_to_uchar_array(const std::string& str, unsigned char out_array[], size_t& out_size) {
    std::istringstream iss(str);
    int num;
    out_size = 0;

    while (iss >> num) {
        if (num < 0 || num > 255) {
            std::cerr << "Number out of range for unsigned char: " << num << "\n";
            continue;
        }
        if (out_size >= SIZE) {
            std::cerr << "Array overflow, ignoring remaining numbers\n";
            break;
        }
        out_array[out_size++] = static_cast<unsigned char>(num);
    }

}

int main() {
    size_t size = 0;
    unsigned char code[SIZE];
    std::string code_str = "77 97 220 67 65 215 37 198 19 170 67 10 156 4 140 2 122 67 1 115 1 99 3 93 67 4 85 7 76 9 71 76 9 69 67 17 72 18 74 19 75 67 19 76 20 80 21 84 67 24 104 28 113 37 117 67 44 121 52 122 61 122 67 78 122 91 117 96 107 67 99 103 100 97 102 90 67 103 81 104 79 106 77 67 110 74 116 75 118 79 67 119 80 120 84 120 88 67 121 92 122 97 122 99 67 124 105 128 111 132 114 67 142 122 160 125 175 121 67 192 117 198 109 201 84 67 202 80 203 76 203 75 67 204 74 206 72 210 70 67 212 69 212 69 213 70 67 214 71 217 82 218 87 67 221 101 221 120 218 134 67 212 162 195 187 171 203 67 157 212 141 218 125 220 67 118 220 103 220 97 220 90 77 113 179 76 113 169 67 116 168 118 168 119 168 67 122 168 127 167 134 165 76 135 165 76 135 176 67 146 171 156 164 163 157 67 167 152 169 149 169 147 67 169 146 167 144 166 144 67 165 144 163 145 161 147 67 143 158 123 164 105 162 67 90 161 75 156 61 147 67 59 145 57 144 56 144 67 55 144 53 146 53 147 67 53 149 55 152 59 157 67 65 163 73 170 82 174 76 86 176 67 87 168 87 165 87 165 67 87 165 90 166 93 166 67 96 167 101 168 102 168 67 104 168 106 168 107 168 76 108 169 76 108 190 76 113 190 90 77 55 110 67 46 109 41 107 39 103 67 35 97 31 73 33 68 67 34 67 35 67 37 66 67 47 63 61 62 73 64 67 82 65 87 67 89 71 67 90 73 90 73 90 80 67 90 92 88 100 83 105 67 77 109 65 112 55 110 90 77 76 104 67 82 101 86 90 84 80 67 80 66 67 63 61 76 67 60 79 59 82 59 87 67 59 95 63 102 68 104 67 70 105 74 105 76 104 90 77 153 110 67 147 109 141 107 139 104 67 135 99 132 89 132 78 67 132 68 138 64 156 63 67 165 62 174 63 182 65 67 187 66 188 67 189 69 67 191 73 189 91 185 100 67 183 105 181 107 175 109 67 167 111 159 111 153 110 90 77 155 104 67 158 103 161 98 163 93 67 163 90 163 83 163 80 67 161 72 156 68 151 68 67 148 68 145 69 143 72 67 140 75 138 80 138 87 67 138 92 139 95 141 99 67 142 101 145 104 147 105 67 149 105 153 105 155 104 90 77 105 62 67 99 62 97 61 93 59 67 84 53 73 50 60 50 67 47 50 36 53 25 58 67 21 59 19 60 17 60 67 15 60 14 60 14 60 67 14 59 17 53 20 49 67 26 41 35 30 43 24 67 59 12 78 4 98 2 67 104 1 118 1 125 2 67 144 4 163 12 179 24 67 187 30 196 41 202 49 67 205 53 208 59 208 60 67 208 60 207 60 205 60 67 203 60 201 59 198 58 67 178 49 153 48 136 55 67 133 57 131 57 128 60 67 126 61 124 61 122 62 67 119 62 108 62 105 62 90 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0";
    
    parse_to_uchar_array(code_str, code, size);
    
    CommandQueue q;

    q.parse(code, size);
    q.draw();

    return 0;
}